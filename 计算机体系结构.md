# 计算机体系结构

## 1.六个在计算机体系中的伟大结构

### **1.抽象(我们如何抽象出计算的各个层次并代表它们，使得其他层次不必考虑底层的细节)**

在计算机科学中，抽象是一种分层设计思想，用于简化复杂系统，通过隐藏底层细节来关注更高层次的概念。以下是抽象在计算各个层次中的实现方式，以及如何通过分层设计让每一层不必关心底层的具体实现。

**1. 硬件抽象**

- **门电路和逻辑电路**：在最底层，计算机的硬件由逻辑门（如与门、或门、非门等）组成，这些门电路通过组合形成加法器、乘法器等基本计算单元。逻辑设计通过将这些逻辑电路抽象为基本的运算单元，使得电路设计者能够在不关心电子电流的具体变化细节的情况下设计计算功能。
- **指令集架构（ISA）**：硬件上进一步抽象为指令集架构，为上层软件提供统一的接口。例如，x86和ARM等架构定义了一组标准指令，操作系统和编译器可以在不考虑底层硬件实现差异的情况下生成指令。ISA屏蔽了硬件设计的复杂性，使得不同硬件架构可以支持相同的高级语言指令。

**2. 操作系统抽象**

- **进程和线程管理**：操作系统抽象了CPU时间的使用，为每个程序提供了独立的执行环境（进程）。进程间的资源管理、内存分配由操作系统统一调度，应用程序不需要考虑具体的CPU或内存管理细节，而是通过系统调用来实现进程通信和资源访问。
- **文件系统**：操作系统为磁盘存储提供了文件系统抽象，允许用户和程序以文件和目录的形式存储和访问数据，而不需要考虑数据在物理磁盘上的实际位置。文件系统抽象帮助用户和应用更直观地访问存储设备，并在不同设备和平台之间实现统一的存储接口。

**3. 编程语言抽象**

- **高层语言**：如C、Python、Java等编程语言通过语法和库函数对硬件和操作系统的功能进行抽象。程序员可以使用`print()`这样的简单函数来实现输出，而不需要关注底层如何访问硬件。
- **中间表示和虚拟机**：高级语言如Java、Python、JavaScript等会在底层使用虚拟机（如JVM、Python解释器）来运行代码。虚拟机为跨平台的程序提供了一层抽象，使得编写的代码可以在不同操作系统上运行，而不需要考虑每个平台的差异。

**4. 应用层抽象**

- **应用接口（API）和库**：软件库和API封装了复杂功能的实现，使得开发者可以通过调用API来实现高级功能。比如，机器学习库（如TensorFlow、PyTorch）提供了模型训练的接口，开发者无需关心底层矩阵运算的实现细节。
- **微服务和分布式系统**：现代应用系统将功能模块划分为独立的微服务，每个微服务通过标准接口（如RESTful API）进行通信。每个微服务都是一个封装的功能单元，客户端可以直接调用服务，而无需了解具体的实现细节或数据处理过程。

**5. 网络层抽象**

- **OSI模型**：网络通信被分为7层（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层）。每一层都提供特定的通信功能，并为上一层提供服务。例如，传输层（TCP/UDP）在网络层之上提供数据传输可靠性的抽象，而应用层（HTTP、FTP等）则在传输层之上提供数据交换服务，应用程序不必关心数据的实际传输过程。
- **协议和封装**：各层的协议抽象（如HTTP、TCP、IP）允许应用在不考虑底层网络链路如何传输数据的情况下进行通信。通过分层的协议栈，每一层的实现可以独立更换或优化，而不会影响上层的通信逻辑。

**6. 抽象带来的好处**

通过层次化的抽象，每一层都专注于处理它的功能，从而隐藏了底层实现的复杂性。这种设计不仅提高了系统的可维护性和可扩展性，还允许开发者快速构建复杂系统，因为他们只需要理解所在层级的接口和抽象，而无需深入底层的实现细节。这种结构的优势包括：

- **模块化和可维护性**：每一层可以独立修改或优化，且不会影响到其他层的功能。
- **可重用性**：通过接口和API，功能可以重复使用而无需重新实现。
- **跨平台性**：通过虚拟机或标准协议的抽象，实现跨平台的兼容性。

### **2.摩尔定律和缩放原理**

1.摩尔定律由英特尔联合创始人戈登·摩尔提出，最初的表述是每隔大约两年，集成电路上的晶体管数量会翻倍，而微处理器的性能也会相应提升。这一趋势促使计算机性能不断提升，同时成本相对降低，驱动了半导体产业的发展。

**具体含义**：

- 晶体管密度：摩尔定律最直接的表现就是单位面积上晶体管数量的增加，从而允许更多的功能集成在同一块芯片上。
- 性能提升：晶体管数量的增加使得计算能力显著提升，同时也改进了存储容量和处理速度。
- 成本控制：随着技术进步，每个晶体管的生产成本逐渐降低，使高性能计算设备更具经济性。

**局限性**： 摩尔定律并不是一条物理定律，而是一种经验观察，随着工艺制程逐渐逼近物理极限，摩尔定律的增长速度逐渐放缓。此外，功耗和散热问题也在限制芯片的进一步缩小。

2.缩放原理主要用于描述随着系统或对象尺寸的改变，其物理特性如何变化。在计算机科学和信息技术中，缩放原理常用于芯片制造中描述晶体管缩放和性能优化的关系。

**基本概念**：

- **线性缩放**：在缩小工艺尺寸时，晶体管的面积成比例缩小，使得同一芯片面积上能够容纳更多的晶体管，从而提高计算能力。
- **功率缩放**：随着晶体管的体积减小，每个晶体管的功率消耗也相应减少，有助于降低总体功耗和散热需求。
- **延迟缩放**：缩小尺寸后，信号在电路中传递的距离缩短，从而降低了延迟，提高了响应速度。

**应用**： 缩放原理支持了摩尔定律的发展，为集成电路提供了微型化和高效能发展的基础。通过缩小每个晶体管的尺寸，芯片不仅能在相同面积上集成更多晶体管，还可以实现更高效的功耗管理和更快的响应速度。

### **3.局部性原理和存储器层次结构(每一层内存的量都增加了一个数量级，价格便宜了一个数量级，并且变慢了一个数量级)**

**1.局部性原理**

局部性原理（Principle of Locality）是指程序在运行时通常会集中访问某些特定的数据和代码区域，因此可以通过在较小、更快的存储器中缓存这些区域来提高运行效率。局部性原理通常分为以下两种类型：

1. **时间局部性（Temporal Locality）**：程序在一段时间内会多次访问相同的内存位置。例如，循环中的变量或数组元素在短时间内被频繁访问，适合缓存到更快的存储器中。
2. **空间局部性（Spatial Locality）**：程序在访问某一内存位置后，其周围的内存位置也很可能被访问。比如，数组中的连续元素或顺序执行的指令具有空间局部性，适合将相邻的内存块一起缓存。

局部性原理通过减少CPU从慢速存储器（如主存）获取数据的频率来提高系统性能，这是存储器层次结构设计的基础。

**2.存储器层次结构**

存储器层次结构（Memory Hierarchy）是利用存储器性能和成本的差异来优化数据访问的层次化设计，从而实现存储系统的高效性和经济性。它包括以下几个层次，从速度和成本最高到最低依次排列：

1. **寄存器（Registers）**：
   - 位于CPU内部，是最快的存储器。
   - 用于存放当前正在处理的数据和指令，容量极小，一般仅用于短期操作数的存储。
2. **缓存（Cache）**：
   - 分为L1、L2和L3缓存，靠近CPU，访问速度快。
   - 通过缓存常用的数据和指令减少访问主存的次数。缓存通常较小，但对系统性能有很大影响。
   - 基于局部性原理，缓存将最近访问的数据或相邻数据块存储，以加速后续访问。
3. **主存（Main Memory / RAM）**：
   - 是系统的主要存储区域，存放正在运行的程序和数据。
   - 速度较缓存慢，但容量大，适合存放大量数据。
   - CPU从主存加载数据到缓存或寄存器中，然后对数据进行处理。
4. **磁盘存储（Disk Storage）**：
   - 包括硬盘（HDD）、固态硬盘（SSD）等，提供持久性存储。
   - 存储容量大、成本低，适合长期存储数据，但访问速度比主存慢得多。
   - 操作系统在内存不足时会使用虚拟内存，将不常用的数据放入磁盘，以腾出内存空间。
5. **外部存储（External Storage）**：
   - 如磁带、光盘、云存储等，用于存储不常访问的数据。
   - 外部存储容量非常大，成本低，但访问速度慢，通常用于备份和长期存储。

**3.存储器层次结构的工作原理**

存储器层次结构利用了局部性原理，将频繁访问的数据存储在速度更快、靠近CPU的层级中。每当CPU需要数据时，它首先从寄存器或缓存中查找，若未命中（缓存未命中），则逐步从更低层的存储器中查找，直到找到数据。这种分层结构使得程序能快速访问常用数据，同时保留大量较慢的存储来满足高容量需求。

- **缓存命中率**：决定了存储器层次结构的效率。更高的命中率意味着更多的数据可以从缓存中快速获取，而不必访问较慢的存储器层级。
- **虚拟内存**：操作系统利用磁盘空间作为扩展内存，通过分页和分段技术，在主存不足时将不常用数据临时存储在磁盘上，按需加载回主存。

**4.存储器层次结构的优势**

- **性能优化**：存储器层次结构显著减少了CPU等待数据的时间，通过多级缓存提高数据访问速度。
- **成本效益**：将高成本、高速度的存储器用于缓存和寄存器，低成本、大容量的存储器用于长期存储，实现了性能和成本的平衡。
- **扩展性**：通过虚拟内存和外部存储，存储系统能够应对数据量增加带来的挑战。

存储器层次结构通过分层设计与局部性原理的结合，为计算机系统在存储性能和成本上提供了良好的优化。

### **4.并行性(计算机里面的许多事情都在同时发生)**

并行性是指在计算机中，多个操作或任务可以在同一时间内发生，从而提升计算效率和性能。计算机系统的并行性体现在多个层面，从硬件到软件的不同组件都可以同时执行任务，以加速处理速度。

### **5.性能测量以及根据测量结果的改进(关于性能测量的重要事情是我们确实想要衡量我们关心的内容，而这通常是延迟和吞吐量)**

延迟：完成任务需要多长时间

吞吐量：在给定时间内我们可以完成多少任务

### **6.可靠性和冗余的反馈**

冗余的原则是说一个失败的部分并不意味着整个系统会失败。

## 2.数字表示

你需要将模拟转变成数字形式才能处理它们并对其进行操作。

### 1.如何将模拟数据转换为数字数据

1.我们必须取样

我们必须在每个时间步骤询问它，你的值是多少

2.主要观点：比特可以代表任何东西

3.n位是2的n次方个东西

### 2.二进制，十进制和十六进制

Example:

3271的10进制书写：`3*10^3+2*10^2+7*10^1+1*10^0`

1101的二进制换成10进制：`1*2^3+1*2^2+0*2^1+1*2^0=13 `

A5的16进制换成10进制：`10*16^1+5*16^0=165`

每个基数都是10进制

| D    | H    | B    |
| ---- | ---- | ---- |
| 00   | 0    | 0000 |
| 01   | 1    | 0001 |
| 02   | 2    | 0010 |
| 03   | 3    | 0011 |
| 04   | 4    | 0100 |
| 05   | 5    | 0101 |
| 06   | 6    | 0110 |
| 07   | 7    | 0111 |
| 08   | 8    | 1000 |
| 09   | 9    | 1001 |
| 10   | A    | 1010 |
| 11   | B    | 1011 |
| 12   | C    | 1100 |
| 13   | D    | 1101 |
| 14   | E    | 1110 |
| 15   | F    | 1111 |

D十进制，H十六进制，B二进制

从右边开始或者填充，使其总是四的倍数

八个比特被称为一个字节

### 3.数字表示

我们可以在数字表示里做到的：相加，相减，相乘，相除，比较它们。

如果结果无法存储在我们必须分配的位数中，我们称之为溢出。

溢出：

00000->00001->00010->...->11110->11111->000000(两个00000)

它们都是unsigned(无符号的)

### 4.如何表示负数

最左边的位将成为我的符号

1开头代表负数，0开头代表正数

00000=10000(代表为0的点)

### 5.二进制补码和偏置编码

#### 一、二进制补码（Two's Complement）

二进制补码是计算机中表示和处理带符号整数的主要方法，它在计算机系统中占有重要地位，因为补码可以简化运算过程，使得加减运算不需要专门区分正负数处理。补码表示不仅能够有效处理负数，还支持计算机中的算术运算。

##### 1. 补码的基本原理

补码是通过对二进制数进行转换，将负数表示为一组独特的二进制数。在补码表示中，正数和负数可以通过最高位（符号位）区分：

- 最高位为`0`表示正数。
- 最高位为`1`表示负数。

##### 2. 补码的计算方法

对于一个带符号整数`x`，其补码表示可以分为以下几种情况：

- **正数的补码**：正数的补码表示与其原码（标准的二进制形式）相同。

- 负数的补码：

  负数的补码表示通过以下步骤得到：

  1. 将该负数的绝对值转换为二进制（原码）。
  2. 按位取反，即把`0`变为`1`，`1`变为`0`。
  3. 最后，**将结果加1**，得到补码。

##### 3. 补码的特点和作用

- **符号位**：补码中的最高位是符号位，`0`表示正数，`1`表示负数。
- **便于运算**：在补码表示中，加法和减法可以使用同一种运算方式，不需要单独处理减法。负数的加减法可直接在补码基础上进行，无需特殊处理。
- **表示范围**：对于一个n位的带符号整数，补码可以表示的范围是`-2^(n-1)` 到 `2^(n-1)-1`。例如，8位补码可以表示的范围是`-128`到`127`。

##### 4. 补码的示例

##### **8位补码举例**：

- 正数`5`的补码表示：`0000 0101`（与原码相同）。
- 负数-5的补码计算过程：
  1. 先写出`5`的原码：`0000 0101`。
  2. 按位取反：`1111 1010`。
  3. 加`1`：`1111 1010 + 1 = 1111 1011`，即`-5`的补码为`1111 1011`。

##### 5. 补码的应用

补码广泛用于整数运算和存储，特别是带符号整数的运算，因为它能够简化硬件中的加法器设计。此外，编程语言中通常默认使用补码来表示带符号整数。

#### 二、偏置编码（Biased Encoding）

偏置编码是一种通过加上偏置值来表示负数的方式，通常用于浮点数的指数部分。它主要出现在浮点数的表示中，以便表示较大的指数值范围，并且便于比较大小。

##### 1. 偏置编码的基本原理

偏置编码在表示数值时，通过给数值加上一个固定的偏置值（bias），使得负数可以被表示为非负数。具体来说：

- 偏置编码可以表示负数、零和正数，并且这些值都通过正数的形式存储在内存中。
- 这种方式使得计算机可以方便地对偏置编码进行大小比较。

##### 2. 偏置值的计算方法

假设偏置值为`bias`，一个数`x`的偏置编码`biased_x`计算方法为： `biased_x=x+bias`

这样可以确保所有的负数和零都转换为非负数。通常情况下，偏置值是一个固定的数，比如在IEEE 754单精度浮点数中，偏置值为127；在双精度浮点数中，偏置值为1023。

##### 3. 偏置编码的特点和作用

- **范围扩展**：偏置编码允许表示负指数和正指数的较大范围。通过加偏置值可以支持更广的值范围。
- **便于比较**：偏置编码中，数值的存储是非负的，这使得负数的大小比较操作变得简单。
- **用途**：主要用于浮点数的指数部分表示，而不是直接用于整数运算。

##### 4. 偏置编码的示例

假设偏置值为127，计算以下偏置编码：

- `x = -2`，其偏置编码为 `-2 + 127 = 125`。
- `x = 0`，其偏置编码为 `0 + 127 = 127`。
- `x = 3`，其偏置编码为 `3 + 127 = 130`。

偏置编码可以通过将存储的偏置值减去偏置量来还原实际的数值。例如，如果存储的偏置编码为125，可以通过`125 - 127 = -2`得出原始值。

##### 5. 偏置编码的应用

偏置编码在浮点数标准IEEE 754中应用广泛，用于表示浮点数的指数部分。偏置编码使得浮点数的表示和比较更加简单和统一，因此在硬件实现中更有效。

#### 三、二进制补码和偏置编码的区别

| **特性**           | **二进制补码**                   | **偏置编码**                                 |
| ------------------ | -------------------------------- | -------------------------------------------- |
| **主要用途**       | 表示带符号整数，特别是负数       | 表示浮点数的指数部分                         |
| **表示负数的方法** | 通过按位取反加1                  | 加上一个固定的偏置值使负数成为非负数         |
| **符号位**         | 最高位表示符号（0为正，1为负）   | 不存在符号位，所有值为非负                   |
| **优点**           | 运算方便，加法和减法无需特别处理 | 更适合浮点数指数表示，便于范围扩展和大小比较 |
| **适用场景**       | 整数运算、带符号整数表示         | 浮点数表示的指数部分，如IEEE 754浮点标准     |
| **典型的数值范围** | `-2^(n-1)` 到 `2^(n-1)-1`        | 偏置值决定范围，如IEEE 754单精度偏置为127    |

#### 四、总结

- **二进制补码**和**偏置编码**是计算机中表示负数的两种方法，但应用场景和实现方式不同。
- **二进制补码**主要用于整数的存储和运算，简化了加减法操作，使得硬件设计更加高效。
- **偏置编码**主要用于浮点数的指数部分表示，它通过加偏置值扩展了指数范围，并且便于指数的比较和表示。

## 3.C语言：基础

### 1. 程序在计算机上运行的方式

主要有两种方式 编译或解释

编译器是一个程序，他接受C程序并输出特定于该架构的内容，从高阶到低阶，局限于该特定架构。

C语言文件通过编译器编译成汇编语言，然后通过链接器linker与库链接在一起形成可执行文件。在链接时构建.out或实际的可执行文件

编译后的文件是特定于文件的，因此.o文件和可执行文件是特定于机器的，这意味着当你将它们移植到另一个系统或不同的操作系统时，你必须进行适配。

重新编译并将其移植到另一个架构的想法被称为将代码移植。

任何以#号或者#号开头的东西是一个CPU处理器命令。

#include的作用是抓取.h文件并将其放入.i文件中

C预处理器可以让你定义宏，但是可能使代码难以调试。

### 2.main函数

`int main(int argc,char *argv[])`

argc有两个：一个是sort，一个是myfile。

argv：是一个指向字符串数组的指针（argument vector），每个元素都是一个字符串，代表命令行中的一个参数。`argv[0]` 通常是程序的名称，`argv[1]` 到 `argv[argc-1]` 是实际传递给程序的其他参数。

## 4.C语言：指针，数组，字符串

### 1.指针

指针是一个单元，其值是别人的地址

通过使用子程序来更改顶层值的方法，必须使用指针。

指向通用类型的指针，这称为你声明了一个void* 指针，我们可以通过一些类型转换然后将其移动。

NULL指针意味着它指向空

现代机器是字节可寻址的。

sizeof是一个运算符，任何类型的大小都会告诉你该类型有多少个字节宽。

### 2.数组

你可以通过声明类型和数量来进行定义，例如:

```c
int arr[20];
```

数组是向C请求连续内存块的一种方式。

大多数数组和指针实际上是相同的。

数组变量指向第一个元素

你传递一个数组，你必须传递数组，你还得传递数组的大小或者至少是你将要搜索的数量。

### 3.字符串

字符串末尾有终止符，所以它传递时不需要说明数组的大小。

## 5.C语言：内存

除了数组外，动态请求内存的方式，我们之前还讨论过使用malloc

malloc可以在内存中开辟一块空间来进行使用

realloc可以对malloc开辟的空间进行修改

例如：

```c
int* ip;
ip = malloc(sizeof(int)*10);//创建一个10个int整型的空间
ip = realloc(ip,20*sizeof(int));//把这个空间扩大到20个int整型
free(ip);
```

数组和指针基本上一样，除了它们存储的位置以及不能递增一个数组的变量

### 内存的实际位置

当我们声明一个结构体时，我们不会为它保留内存，但是我们声明一个变量时，我们会为它保留内存。

C语言有三个不同的内存池

1.静态存储区：这是全局空间，他是静态的，代表不会移动，不会变化

2.栈区：用于存储局部变量，参数，返回地址

3.堆：动态分配的内存在堆上

有三种方式来处理malloc将影响的空闲列表

1.最佳适配：搜索所有块直到找到最合适的块

2.首次适配：总是从头开始，首个大于等于你请求空间大小的块就分配给你

3.下次适配：与首次适配相同，除了你总是记住上次的位置，下次就从那里开始

## 6.浮点数

二进制的小数点，它的位置不同于实际存储的比特位，称之为有效位。

当我们存取1.0 * 10-9时

标准模式：1.0 * 10-9

不标准模式为：0.1 * 10-8，10.0 * 10-10

float浮点数就是以这种方式存储，小数点的左边总是1

- **标准格式**: +1.xxx...xxx₂ * 2ʸʸʸ...ʸ₂
- **字长的倍数** (32位)

| 位段  | 说明                 | 位数  |
| ----- | -------------------- | ----- |
| 31    | 符号位 (S)           | 1 位  |
| 30-23 | 指数 (Exponent)      | 8 位  |
| 22-0  | 有效位 (Significand) | 23 位 |

在符号位时，1表示负数，0表示正数。

1+23位有效位为float，1+52位有效位为double

- **称为偏移表示法**，其中偏移值是从指数中减去的数字，用于得到实际的指数值
  - IEEE 754 对单精度使用 127 的偏移值
  - 从指数字段中减去 127 来得到实际的指数值

- **总结**（单精度或 fp32）：

| 位段  | 说明                 | 位数  |
| ----- | -------------------- | ----- |
| 31    | 符号位 (S)           | 1 位  |
| 30-23 | 指数 (Exponent)      | 8 位  |
| 22-0  | 有效位 (Significand) | 23 位 |

- **公式**：
  `(-1)^S * (1 + Significand)  * 2^(Exponent-127)`

- 双精度与此相同，只是指数的偏移值为 1023（半精度和四倍精度类似）

### 特殊数字

**如果我计算 sqrt(-4.0) 或 0/0，会得到什么？**

- 如果 ∞ 不是一个错误，那么这些也不应该是错误。
- 称为 “非数字”（Not a Number, NaN）
- 指数 = 255，有效位非零

**为什么这有用？**

- 希望 NaN 可以帮助调试？
- 它们会污染结果：op(NaN, X) = NaN(它与任何数进行运算都等于它本身)
- 可以使用有效位来识别是哪种情况！

**问题：在 0 附近，可表示的浮点数之间存在间隙**

- **最小的可表示正数**：

a = 1.0...0₂ × 2^(-126) = 2^(-126)

- **第二小的可表示正数**：

b = 1.000...1₂ × 2^(-126) = (1 + 0.00...01₂) × 2^(-126) = (1 + 2^(-23)) × 2^(-126) = 2^(-126) + 2^(-149)

- **差值**：

a - 0 = 2^(-126) 

b - a = 2^(-149)

**归一化和隐含的 1 是导致间隙的原因！**在数字线上：
- `a` 和 `b` 之间有间隙（Gaps）。
- 从负无穷到正无穷之间有类似的间隙。

**解决方案：**

- 我们仍然没有使用 **Exponent = 0** 且 **Significand 非零** 的情况。
- **非规范化数（Denormalized number）**：没有（隐含的）前导 1，隐含指数为 -126。
- **最小的可表示正数**：
- a = 2^(-149)
- **第二小的可表示正数**：
- b = 2^(-148)
- 在数字线上：
- 从负无穷到正无穷之间，包含这些非规范化数，可以表示更小的间距。

### 浮点数与10进制数之间的转换

**问题：以下二进制浮点数的十进制等价值是多少？**

| S    | Exponent  | Significand                       |
| ---- | --------- | --------------------------------- |
| 1    | 1000 0001 | 111 0000 0000 0000 0000 0000 0000 |

计算步骤：

1. 公式：
   (-1)^S * (1 + Significand)  * 2^(Exponent-127)
2. 代入值：
   (-1)^1 * (1 + .111)_2 * 2^(129-127)
3. 简化：
   -1 * (1.111)_2 * 2^(2)
5. 结果：
   -1 * (111.1)_2

**答案：**(-7.5)_10

### 浮点数的一些讨论

1.浮点数在加法中是不能被交换的

x = -1.5 * 10^38,y = 1.5 * 10^38,z = 1.0

x + (y + z) = -1.5 * 10^38 + (1.5 * 10^38 + 1.0)

​				 = -1.5 * 10^38 + 1.5 * 10^38 = 0.0

(x + y) + z = (-1.5 * 10^38 + 1.5 * 10^38) + 1.0

​				 = (0.0) + 1.0 = 1.0

如果你有一个非常大的数和一些非常小的数，你无法同时保留两者。

精确度是指你编码的任何数值与原始实际数值之间的距离

通常浮点硬件在最右边会保留一些额外的位，称为舍入位，这些额外的位可用于判断应该向上舍入到更大的浮点数，还是向下舍入到更小的浮点数

**舍入规则**

- **向正无穷舍入（Round towards +∞）**
  - 总是“向上”舍入：2.001 → 3，-2.001 → -2

- **向负无穷舍入（Round towards -∞）**
  - 总是“向下”舍入：1.999 → 1，-1.999 → -2

- **截断（Truncate）**
  - 仅丢弃最后的位数（向 0 舍入）

- **无偏舍入（默认模式，Unbiased / Default Mode）。中点？向偶数舍入（Midway? Round to even）**
  - 正常舍入，接近值：2.4 → 2，2.6 → 3，2.5 → 2，3.5 → 4
  - 类似你在学校学习的四舍五入（最接近的整数）。
  - 特例：如果值正好在边界上，向最接近的**偶数**舍入。
  - 确保计算的公平性。
  - 通过这种方式，一半的情况下，我们在平局时向上舍入，另一半情况下向下舍入。这样可以平衡舍入误差。

## 7.risc-v介绍

适用于处理器或一类处理器的特定指令集称为指令集架构。

32位处理器的可操作字节为4个字节，64位是一次操作8个字节。

### 体系结构的元素

指令集是一种特定体系结构可以执行的指令集合

**1.体系结构的第一个元素是寄存器**

寄存器是位于处理器内核中的硬件对象，数量有限

对数据的操作是在寄存器中的数据上进行的。

优点：由于它们就在处理器内核和执行计算单元的附近，所以它们非常快。

处理器负责协调从IO设备加载内存和将数据从内存发送到输出设备

字的宽度是与架构的变种相关联的

**2.汇编语言**

在汇编语言中，每个语句称为指令，每一行汇编语言最多包含一条指令。

### RISC-V的加法减法指令

**汇编中的加法**

- 示例：`add x1, x2, x3`（在 RISC-V 中）
- 相当于：`a = b + c`（在 C 语言中）
- 其中 C 语言变量和 RISC-V 寄存器的对应关系为：
  - `a` ⇔ `x1`
  - `b` ⇔ `x2`
  - `c` ⇔ `x3`

**汇编中的减法**

- 示例：`sub x3, x4, x5`（在 RISC-V 中）
- 相当于：`d = e - f`（在 C 语言中）
- 其中 C 语言变量和 RISC-V 寄存器的对应关系为：
  - `d` ⇔ `x3`
  - `e` ⇔ `x4`
  - `f` ⇔ `x5`

### RISC-V数值常量

- **立即数**是数值常量。
- 它们在代码中经常出现，因此有专门的指令来处理它们。
- 加立即数：
  - 示例：`addi x3, x4, 10`（在 RISC-V 中）
  - 相当于：`f = g + 10`（在 C 语言中）
  - 其中 RISC-V 寄存器 `x3` 和 `x4` 对应于 C 变量 `f` 和 `g`。
- 语法类似于加法指令，只是最后一个参数是数字而不是寄存器。

**RISC-V 中没有减立即数指令：为什么？**

- 有 `add` 和 `sub`，但没有对应的 `addi`（加立即数）减法指令。

**限制可以执行的操作类型至绝对最小化**

- 如果某个操作可以被分解为一个更简单的操作，那么就不要包含它。
- 例如：`addi ..., -x = "subi ..., x"`，因此没有 `subi` 指令。
- 示例：`addi x3, x4, -10`（在 RISC-V 中）
  - 相当于：`f = g - 10`（在 C 语言中）
  - 其中 RISC-V 寄存器 `x3` 和 `x4` 分别与 C 变量 `f` 和 `g` 关联。

### 特殊的立即数：数字零（0）

- 数字零在代码中非常常见。
- 因此寄存器零（x0）被“硬连接”到值 0；
  - 例如：add x3, x4, x0（在 RISC-V 中）
    - 相当于：`f = g`（在 C 语言中）
  - 其中 RISC-V 寄存器 `x3` 和 `x4` 分别与 C 变量 `f` 和 `g` 关联。

**由于在硬件中被定义，所以指令 `add x0, x3, x4` 不会做任何事情！**

## 8.RISC-V lw，sw，Decision|

**1.add rd,rs1,rs2**

R[rd] = R[rs1] + R[rs2]

**2.sub rd,rs1,rs2**

R[rd] = R[rs1] - R[rs2]

**3.addi rd,rs1,imm**

R[rd] = R[rs1] + imm

通常优化编译器的工作就是最小化寄存器的使用

对于特定内核使用的寄存器数量被称为该内核的寄存器足迹

地址通常被认为相对于一个基指针的偏移量，每个在内存中布局的数组都有它的基指针

我们总是从内存加载并存储到内存

### 1.内存中数据的布局

内存被组织成字，在RISC-V架构中，字长为32位

在这里，四个字节组合成一个字，每个字节8位

在RISC-V架构中，它们遵循一种有趣的约定，叫做小端序

小端序：一个字中最低有效字节，这个字节，获得该字中最小的地址，因此占据了字的0到7位

本质上，字的地址与最低有效字节的地址相同

字节序只管理字节在内存中的存储顺序，位的存储顺序总是相同的，最低有效位在最低位置。

### 2.内存数据传输的指令

1.在RISC-V中，LOADWORD从内存加载数据到寄存器

lw x10,12(x15)

**`lw`**：这是加载字（load word）指令，用于从内存中读取一个32位的数据（word），并加载到指定的寄存器中。

2.在RISC-V中。Store word(sw)从寄存器存储到内存。

sw x10,40(x15)

`sw` 是**存储字**（Store Word）指令，用于将寄存器中的32位数据存储到内存中。

注意：这些偏移量，对于加载和存储应该是4的倍数

3.在RISC-V中，支持符号字节加载，这是另一个指令，它从内存中复制一个字节，从内存加载一个字节到寄存器，但不执行符号扩展

除了字数据传输（`lw`、`sw`）之外，RISC-V还有字节数据传输：

- 加载字节：`lb`
- 存储字节：`sb`
- 与 `lw`、`sw` 格式相同

例如：

```scss
lb x10, 3(x11)
```

- 内存位置的内容，地址为“3”加上寄存器 `x11` 的内容，被复制到寄存器 `x10` 的低字节位置。

RISC-V 中确实有“无符号字节加载”（`lbu`）指令，但没有对应的“无符号存储字节”（`sbu`）指令。这背后的原因涉及到字节存储和加载的概念差异：

1. **加载的符号扩展和零扩展**：
   - 在加载操作中，有符号加载（`lb`）和无符号加载（`lbu`）之间的差异在于数据扩展的方式。
   - `lb` 会将从内存中加载的字节进行**符号扩展**，即如果最高位是 1，则扩展为负数的形式。
   - `lbu` 会将从内存中加载的字节进行**零扩展**，即不管最高位是什么，都扩展为正数的形式。
   - 因为寄存器是 32 位或者 64 位，加载操作需要考虑如何扩展到更大的位数，所以需要无符号加载（`lbu`）来确保值保持为正数。
2. **存储操作没有符号扩展的需求**：
   - 存储操作（`sb`）是将寄存器中的数据写入内存中的一个字节，而存储字节的时候并不需要进行符号或零扩展的处理。
   - 存储操作只涉及把数据的最低 8 位写入到内存中，无论数据是有符号还是无符号，对内存位置的存储结果都是一样的。因此，**不需要区分“符号”或“无符号”存储**。
   - 换句话说，存储操作本质上是直接把数据写入到内存，没有额外的扩展需求，因此一个 `sb` 指令已经足够，没有必要再引入类似 `sbu` 的指令。

因此，RISC-V 设计中没有无符号存储字节指令（`sbu`），因为无论是符号扩展还是零扩展对存储操作都没有影响，**存储的字节本质上是相同的**。这样可以减少指令集的复杂性，同时保持功能的完整性。

### 3.更多的汇编指令

基于计算，执行不同的操作。在编程语言中，这通常是通过 `if` 语句实现的。

在 RISC-V 中，`if` 语句对应的指令是：

```scss
beq reg1, reg2, L1
```

含义：如果寄存器 `reg1` 中的值等于寄存器 `reg2` 中的值，则跳转到标签为 `L1` 的语句执行。否则，继续执行下一条指令。

- `beq` 代表“如果相等则分支跳转”（branch if equal）。
- 另一个指令是 `bne`，表示“如果不相等则分支跳转”（branch if not equal）。

**分支 - 控制流的变化**

**条件分支** - 根据比较结果改变控制流

- 如果相等则分支（`beq`）或如果不相等则分支（`bne`）
- 也可以在小于时分支（`blt`）或大于等于时分支（`bge`）
- 还有无符号版本（`bltu`，`bgeu`）

**无条件分支** - 总是分支

- RISC-V 中的指令是：跳转（`j`），例如 `j label`

一般程序也需要测试 `<` 和 `>`。

**RISC-V 大小比较分支指令：**

“**小于时分支**”

- 语法：`blt reg1, reg2, Label`
- 含义：如果 (`reg1 < reg2`)，则跳转到 `Label`

“**小于时的无符号分支**”

- 语法：`bltu reg1, reg2, Label`
- 含义：如果 (`reg1 < reg2`)，并且将寄存器视为无符号整数，则跳转到 `Label`

此外还有“**大于等于时分支**”：`bge` 和 `bgeu`
**注意**：没有 `bgt` 或 `ble` 指令。

## 9.RISC-V的逻辑指令

### 1.逻辑运算符

- 有用的操作：
  - 在一个字的位字段（fields of bits within a word）中进行操作。
    - 例如，字中的字符（8位）。
  - 打包（pack）或解包（unpack）位到字中进行操作。
  - 这些操作被称为**逻辑操作（logical operations）**。

------

**逻辑操作的对照表：**

| **逻辑操作**                        | **C语言运算符** | **Java运算符** | **RISC-V指令** |
| ----------------------------------- | --------------- | -------------- | -------------- |
| **按位与（AND）**                   | `&`             | `&`            | `and`          |
| **按位或（OR）**                    | `|`             | `|`            | `or`           |
| **按位异或（XOR）**                 | `^`             | `^`            | `xor`          |
| **逻辑左移（Shift Left Logical）**  | `<<`            | `<<`           | `sll`          |
| **逻辑右移（Shift Right Logical）** | `>>`            | `>>`           | `srl`          |

------

简要说明：

- **C语言和Java运算符**提供了常用的按位运算支持，通常用于位级别操作（如掩码、移位等）。
- **RISC-V指令**实现了相同的逻辑操作，在汇编语言层面使用这些指令对寄存器内容进行操作。

**始终有两种变体（Always two variants）**

1. **寄存器形式（Register）：**

   ```assembly
   and x5, x6, x7   # x5 = x6 & x7
   ```

   - 将寄存器`x6`和`x7`按位与的结果存入寄存器`x5`。

2. **立即数形式（Immediate）：**

   ```assembly
   andi x5, x6, 3   # x5 = x6 & 3
   ```

   - 将寄存器`x6`与立即数`3`按位与的结果存入寄存器`x5`。

------

**用于“掩码（masks）”操作**

1. 使用指令`andi`和掩码`0000 00FF_hex`可以**隔离最低有效字节（least significant byte）**。
2. 使用指令`andi`和掩码`FF00 0000_hex`可以**隔离最高有效字节（most significant byte）**。

------

**说明**

- **寄存器形式**用于在两个寄存器之间按位操作。
- **立即数形式**用于寄存器和常数的按位操作，非常适合位掩码应用。

**逻辑左移（Shift Left Logical, sll）和立即数形式（slli）：**

指令格式：

```assembly
slli x11, x12, 2   # x11 = x12 << 2
```

- 将寄存器 `x12` 的值左移 2 位后存入寄存器 `x11`。
- 左移操作会将高位溢出的部分丢弃，同时在右边插入 **0**。
- 类似于 C 语言中的 `<<` 操作符。

------

**示例：**

1. **移位前（Before）：**
   - 值（十六进制）：`0000 0002_hex`
   - 值（二进制）：`0000 0000 0000 0000 0000 0000 0000 0010_two`
2. **移位后（After）：**
   - 值（十六进制）：`0000 0008_hex`
   - 值（二进制）：`0000 0000 0000 0000 0000 0000 0000 1000_two`

------

**问题：左移操作有什么算术效果？**

- **提示：**逻辑左移可以实现乘以2的幂（如左移1位相当于乘以2）。

------

**逻辑右移（Shift Right, srl）：**

- **srl** 是左移的相反操作（对应 C 语言中的 `>>`）。

**算术右移（Shift Right Arithmetic, sra 和 srai）：**

- 将寄存器中的值向右移动 **n** 位。
- 在空位中插入高位符号位（sign bit），以保持符号（正负）的正确性。

------

**示例：**

1. **假设寄存器 `x10` 的初始值：**

   ```yaml
   1111 1111 1111 1111 1111 1111 1110 0111 (二进制)
   ```

   - 该值为 **-25**（十进制，二进制补码表示）。

2. **执行指令：**

   ```assembly
   srai x10, x10, 4
   ```

   - 表示将 `x10` 向右移动 4 位。

3. **执行结果：**

   ```yaml
   1111 1111 1111 1111 1111 1111 1111 1110 (二进制)
   ```

   - 该值为 **-2**（十进制，二进制补码表示）。

------

**注意事项：**

- 算术右移 ≠ 除以 2 的 n 次方（不完全等价）。
  - 对于**奇数负数**，结果不准确。
  - **C语言中的算术语义**：整数除法通常向零取整。

------

总结：

- 算术右移在负数情况下可能会与实际除法操作产生差异。

### 2.编译器特点

**符号寄存器名称（Symbolic register names）**

1. 示例：
   - **`a0-a7`**：用于函数调用的参数寄存器（对应于`x10-x17`）。
   - **`zero`**：表示寄存器 `x0`（值始终为0）。

------

**伪指令（Pseudo-instructions）**

- 是汇编中用于常见操作的简写语法，方便程序员使用。

示例：

1. **`mv rd, rs`**：
   - 等价于 `addi rd, rs, 0`
   - 将寄存器 `rs` 的值移动到 `rd`。
2. **`li rd, 13`**：
   - 等价于 `addi rd, x0, 13`
   - 将立即数 `13` 加载到寄存器 `rd`。
3. **`nop`**（空操作指令）：
   - 等价于 `addi x0, x0, 0`
   - 不执行任何操作，仅占用一个指令周期。

### 3.RISC-V函数调用

调用函数的六个步骤

1.将参数放置在函数可访问的位置

2.传递控制权给函数

3.获取函数所需的局部存储资源

4.执行与函数相关的任务

5.将返回值放置在调用代码可以找到的位置，并恢复任何寄存器到以前的状态，释放局部存储

6.返回控制权给起点，因为函数可以在程序的多个点被调用，程序接管控制权。

在risc-v中的函数调用

**寄存器比内存更快，所以尽量使用寄存器**

1. **`a0-a7`（`x10-x17`）：**
   - 8个**参数寄存器**，用于传递函数的参数和返回值。
   - 其中，`a0` 和 `a1` 用于存储两个返回值。
2. **`ra`（`x1`）：**
   - 一个**返回地址寄存器**，用于存储返回到调用点的地址。
3. **`s0-s1`（`x8-x9`）和 `s2-s11`（`x18-x27`）：**
   - **保存寄存器**，用于存储函数调用期间需要保存的值（具体细节后续讨论）。

**跳转并保存返回地址的单指令：Jump and Link (jal)**

**改进前：**

```assembly
1008 addi ra, zero, 1016   # ra = 1016
1012 j sum                 # 跳转到 sum
```

**改进后：**

```assembly
1008 jal sum               # ra = 1012, 跳转到 sum
```

------

**为什么需要 `jal` 指令？**

1. **优化常见场景：**
   - 函数调用非常常见，`jal` 提供更快的操作。
2. **减少程序大小：**
   - 将两条指令合并为一条，节省代码空间。
3. **无需知道代码在内存中的具体位置：**
   - 使用 `jal` 进行跳转，无需提前计算返回地址。

**调用函数：Jump and Link 指令（`jal`）**

- 实际上应该叫 `laj`（“Link and Jump”）。
- **“Link”** 的含义是创建一个地址或链接，指向调用点，允许函数返回到正确的地址。
- 作用：
  - 跳转到目标地址。
  - 同时将**下一条指令的地址**存储在寄存器 `ra` 中。

**示例：**

```assembly
jal FunctionLabel
```

------

**从函数返回：Jump Register 指令（`jr`）**

- 无条件跳转到寄存器中指定的地址。

**示例：**

```assembly
jr ra
```

- 汇编语言简写形式：

  ```assembly
  ret = jr ra
  ```

  - **`ret`** 表示返回。

**实际上，只有两条指令：**

1. **`jal rd, Label`**：
   - 跳转并链接（jump-and-link）。
2. **`jalr rd, rs, imm`**：
   - 寄存器跳转并链接（jump-and-link register）。

------

**伪指令：**

- **`j`**、**`jr`** 和 **`ret`** 是伪指令！

**对应关系：**

- `j`:

  ```assembly
  jal x0, Label
  ```

  - 表示无条件跳转，不保存返回地址。

## 10.RISC-V 程序

**在调用函数前需要一个地方保存旧值，并在返回时恢复它们，然后删除这些值。**

- 理想的存储方式是

  栈（stack）：

  - 栈是**后进先出（LIFO）**队列（例如：一叠盘子）。

------

**栈的基本操作：**

1. Push：
   - 将数据压入栈中。
2. Pop：
   - 从栈中移除数据。

**栈存储在内存中，因此需要一个寄存器来指向它。**

- 在 **RISC-V** 中，`sp` 是**栈指针（stack pointer）**，对应寄存器 `x2`。
- 约定：栈从**高地址向低地址**增长。

**栈帧（Stack Frame）包含：**

- 返回的**“指令”地址**。
- 参数（Arguments）。
- 为其他局部变量分配的空间。

------

**栈帧是连续的内存块：**

- 栈指针（`$sp`）指示栈帧的底部位置。

------

**当过程结束时：**

- 栈帧从栈中移除（tossed off the stack）。
- 释放内存，以供将来的栈帧使用。

### 1.嵌套过程和它们的寄存器约定

函数必须通过将主程序依赖的那些具有某些值的寄存器放到堆栈上来保存它们

```c
int sumSquare(int x, int y) {
    return mult(x, x) + y;
}
```

**解释：**

1. 有一个叫 `sumSquare` 的函数，现在 `sumSquare` 调用了另一个函数 `mult`。
2. `sumSquare` 函数中保存了一个返回地址（`ra`），用于在函数执行完后跳回调用点。
3. 但是在调用 `mult` 函数时，这个返回地址会被 `mult` 的调用覆盖。

**问题：** 需要在调用 `mult` 之前，将 `sumSquare` 的返回地址保存起来。

**解决方法：** 在调用 `mult` 之前使用**堆栈（stack）**来保存 `sumSquare` 的返回地址.

### 2.寄存器约定

1. **Caller**: 调用函数的一方（调用者）。
2. **Callee**: 被调用的函数（被调用者）。

**描述：** 当被调用函数（callee）执行完返回时，调用者（caller）需要知道哪些寄存器可能已经被修改，哪些寄存器是保证未被修改的。

**寄存器约定（Register Conventions）**： 一套通用的规则，用于规定在过程调用（如 `jal` 指令）之后，哪些寄存器会保持不变，哪些寄存器可能会被修改。它将寄存器分为两类，一类是保存的寄存器，另一类是易失性或称为临时的寄存器。

为了减少因寄存器溢出和恢复操作引起的昂贵加载和存储开销，RISC-V 函数调用约定将寄存器分为两类：

------

1. 跨函数调用保持不变的寄存器
   - 调用者可以依赖这些寄存器的值保持不变。
   - 包括：
     - **`sp`** (堆栈指针)、**`gp`** (全局指针)、**`tp`** (线程指针)
     - **保存寄存器** `s0-s11` (其中 `s0` 也是帧指针 `fp`)

------

1. 跨函数调用不保持不变的寄存器
   - 调用者**不能**依赖这些寄存器的值保持不变。
   - 包括：
     - **参数/返回值寄存器** `a0-a7` 和返回地址寄存器 **`ra`**
     - **临时寄存器** `t0-t6`

### 3.栈

C语言有两种存储类型：**自动（automatic）\**和\**静态（static）**。

1. **自动变量（Automatic variables）**：
   - 局部于函数范围内。
   - 当函数退出时，这些变量会被销毁。
2. **静态变量（Static variables）**：
   - 即使函数退出，这些变量也会保留，并在函数再次调用时保持其值。

------

**栈的用途**：
用于存储无法放入寄存器的**自动（局部）变量**。

------

**过程帧（Procedure frame）或激活记录（Activation record）**：
栈中的一段，用于存储已保存的寄存器和局部变量。

**回忆：**

- **`sp`（栈指针）*始终指向栈中*最后使用的空间**。

------

**使用栈：**

1. 需要使用栈时，将栈指针（`sp`）向下移动（减少指针值），以分配需要的空间。
2. 然后将相关信息填充到这些空间中。

**RV32 约定**（RV64/RV128 具有不同的内存布局）：

- 栈从高地址开始并向下增长。
  - 十六进制地址：`bfff_fff0_hex`
  - 栈必须对齐到**16字节边界**（前面的例子中可能没有严格对齐）。

------

- RV32 程序段（文本段）位于低地址：
  - 十六进制地址：`0001_0000_hex`

------

- 静态数据段：
  - 包含常量和其他静态变量，位于文本段之上。
  - RISC-V 约定中的**全局指针（gp）**指向静态数据段。
  - RV32 的 `gp` 默认值为：`1000_0000_hex`

------

- 堆（Heap）：
  - 位于静态段之上，主要用于存储动态增长和收缩的数据结构。
  - 堆向**高地址**增长。

## 11.RISC-V的指令表示

**一条指令是32位，因此将指令字划分为“字段”**
每个字段向处理器传达指令的一些信息。
我们可以为每种指令定义不同的字段，但RISC-V追求简化，因此定义了六种基本类型的指令格式：

- **R格式**：用于寄存器-寄存器算术操作
- **I格式**：用于寄存器-立即数的算术操作和加载
- **S格式**：用于存储
- **B格式**：用于分支（S格式的次级变体）
- **U格式**：用于20位的上位立即数指令
- **J格式**：用于跳转（U格式的次级变体）

### 1.R格式

| 31     25 | 24  20 | 19   15 | 14   12 | 11   7 | 6      0 |
| --------- | ------ | ------- | ------- | ------ | -------- |
| funct7    | rs2    | rs1     | funct3  | rd     | opcode   |
| 7         | 5      | 5       | 3       | 5      | 7        |

- **32位指令字被划分为六个字段，每个字段的位数不同**：
  7 + 5 + 5 + 3 + 5 + 7 = 32

**示例**：

- **opcode** 是一个7位的字段，占据指令的第6到第0位。
- **rs2** 是一个5位的字段，占据指令的第24到第20位。

- **rs1**（源寄存器#1）：指定包含第一个操作数的寄存器
- **rs2**：指定第二个操作数的寄存器
- **rd**（目标寄存器）：指定将接收计算结果的寄存器

每个寄存器字段保存一个5位无符号整数（0-31），对应一个寄存器编号（x0-x31）。

|         |      |      |      |      |         |      |
| :-----: | ---- | ---- | ---- | ---- | ------- | ---- |
| 0000000 | rs2  | rs1  | 000  | rd   | 0110011 | add  |
| 0100000 | rs2  | rs1  | 000  | rd   | 0110011 | sub  |
| 0000000 | rs2  | rs1  | 001  | rd   | 0110011 | sll  |
| 0000000 | rs2  | rs1  | 010  | rd   | 0110011 | slt  |
| 0000000 | rs2  | rs1  | 011  | rd   | 0110011 | sltu |
| 0000000 | rs2  | rs1  | 100  | rd   | 0110011 | xor  |
| 0000000 | rs2  | rs1  | 101  | rd   | 0110011 | srl  |
| 0100000 | rs2  | rs1  | 101  | rd   | 0110011 | sra  |
| 0000000 | rs2  | rs1  | 110  | rd   | 0110011 | or   |
| 0000000 | rs2  | rs1  | 111  | rd   | 0110011 | and  |

### 2.I格式

**关于带立即数的指令怎么办？**

- 比较：
  - `add rd, rs1, rs2`
  - `addi rd, rs1, imm`
- 5位字段只能表示最大值为31的数字，而立即数可能比这个值大得多。
- 理想情况下，RISC-V应该只有一种指令格式（为了简化）；但遗憾的是，我们需要妥协。

------

**定义一种新的指令格式，与R格式大致一致**

- 注意：如果指令包含立即数，则最多使用两个寄存器（一个源，一个目标）。

**唯一与R格式不同的字段**：`rs2` 和 `funct7` 被12位带符号的立即数 `imm[11:0]` 替代。

其余字段（`rs1`、`funct3`、`rd`、`opcode`）保持不变。

**`imm[11:0]` 的取值范围**：[-2048₁₀, +2047₁₀]。

**立即数在进行算术运算之前始终会被符号扩展为32位**。

后续将介绍如何处理超过12位的立即数。

| 31         20 | 19  15 | 14    12 | 11  7 | 6     0 |
| ------------- | ------ | -------- | ----- | ------- |
| imm[11:0]     | rs1    | funct3   | rd    | opcode  |
| 12            | 5      | 3        | 5     | 7       |

**每列含义**：

- `imm[11:0]`：12位带符号的立即数字段。
- `rs1`：源寄存器字段，占5位。
- `funct3`：功能字段，占3位。
- `rd`：目标寄存器字段，占5位。
- `opcode`：操作码字段，占7位。

**表格总计位数**：12 + 5 + 3 + 5 + 7 = 32 位。

| imm[11:0] / shamt | rs1  | funct3 | rd   | opcode  | Instruction |
| ----------------- | ---- | ------ | ---- | ------- | ----------- |
| imm[11:0]         | rs1  | 000    | rd   | 0010011 | addi        |
| imm[11:0]         | rs1  | 010    | rd   | 0010011 | slti        |
| imm[11:0]         | rs1  | 011    | rd   | 0010011 | sltiu       |
| imm[11:0]         | rs1  | 100    | rd   | 0010011 | xori        |
| imm[11:0]         | rs1  | 110    | rd   | 0010011 | ori         |
| imm[11:0]         | rs1  | 111    | rd   | 0010011 | andi        |
| 0000000 (shamt)   | rs1  | 001    | rd   | 0010011 | slli        |
| 0000000 (shamt)   | rs1  | 101    | rd   | 0010011 | srli        |
| 0100000 (shamt)   | rs1  | 101    | rd   | 0010011 | srai        |

**表格字段说明：**

1. **`imm[11:0]` 字段**：12位立即数字段。
2. **`shamt` 字段**：移位量（Shift Amount）字段，仅使用立即数的低5位值（0-31位移位范围）。
3. 高位立即数位用于区分逻辑右移（SRLI）和算术右移（SRAI）。
4. 表格中的每条指令说明：
   - `addi`、`slti` 等指令为带立即数的指令。
   - 操作码固定为 `0010011`。

### 3.RISC-V的加载操作

只有一种类型进行加载操作，这种类型指定基址寄存器和相对于该基址寄存器的偏移量，偏移量是一个立即数值。它指向一个内存地址。

加载操作有空间容纳一个源寄存器，一个目标寄存器和一个立即数。我们的I格式就能实现。

| 31        20 | 19  15 | 14    12 | 11   | 6     0 |
| ------------ | ------ | -------- | ---- | ------- |
| imm[11:0]    | rs1    | funct3   | rd   | opcode  |
| offset       | base   | width    | dest | LOAD    |
| 12           | 5      | 3        | 5    | 7       |

**表格字段说明：**

1. `imm[11:0]`（偏移量）：12位带符号的立即数被添加到寄存器 rs1中的基址以形成内存地址。
   - 类似于“加立即数”操作，但此处用于创建地址，而不是生成最终结果。
2. **`rs1`（基址寄存器）**：存储基地址。
3. **`rd`（目标寄存器）**：从内存加载的值存储在寄存器 `rd` 中。
4. **`funct3`（宽度）**：指定加载操作的宽度。
5. **`opcode`（加载操作码）**：指定指令类型为 LOAD。

| imm[11:0] | rs1  | funct3 | rd   | opcode  | Instruction |
| --------- | ---- | ------ | ---- | ------- | ----------- |
| imm[11:0] | rs1  | 000    | rd   | 0000011 | lb          |
| imm[11:0] | rs1  | 001    | rd   | 0000011 | lh          |
| imm[11:0] | rs1  | 010    | rd   | 0000011 | lw          |
| imm[11:0] | rs1  | 100    | rd   | 0000011 | lbu         |
| imm[11:0] | rs1  | 101    | rd   | 0000011 | lhu         |

**表格字段说明：**

1. **`lb`**：加载无符号字节（Load Byte Unsigned）。
2. **`lh`**：加载半字（Load Halfword），加载16位（2字节）并符号扩展到目标32位寄存器。
3. **`lhu`**：加载无符号半字（Load Halfword Unsigned），将16位零扩展到目标32位寄存器。
4. **`lw`**：加载字（Load Word），加载32位数据。
5. RISC-V RV32中没有`lwu`，因为从内存位置复制32位数据到寄存器时不需要符号/零扩展。
6. **`funct3` 字段**：编码加载数据的大小和“有符号性”。

### 4.S格式

**表格字段说明：**

1. **存储指令需要读取两个寄存器**：
   - `rs1`：用于基址内存地址。
   - `rs2`：用于存储的数据。
   - 同时还需要一个立即数偏移量。
2. **限制**：不能在与其他指令相同的位置同时拥有 `rs2` 和立即数。
3. **注意**：存储指令不会向寄存器文件写入值，没有 `rd` 字段！
4. **RISC-V 的设计决策**：
   - 将立即数的低5位移动到其他指令的 `rd` 字段位置。
   - 保持 `rs1` 和 `rs2` 字段在相同的位置。
   - 在硬件设计中，寄存器名称比立即数位更为重要。

| 31         25 | 24   20 | 19  15 | 14  12 | 11      7   | 6      0 |
| ------------- | ------- | ------ | ------ | ----------- | -------- |
| imm[11:5]     | rs2     | rs1    | funct3 | imm[4:0]    | opcode   |
| offset[11:5]  | src     | base   | width  | offset[4:0] | STORE    |
| 7             | 5       | 5      | 3      | 5           | 7        |

**说明：**

1. **字段解析**：
   - `imm[11:5]` 和 `imm[4:0]`：立即数分为高7位和低5位，用于偏移量。
   - `rs2`：源寄存器2，用于存储的数据。
   - `rs1`：源寄存器1，基址寄存器。
   - `funct3`：功能码，占3位。
   - `opcode`：操作码，占7位，表示存储操作。
2. **设计特点**：
   - 存储指令设计避免了直接使用 `rd` 字段，腾出空间来存放立即数的低位部分。
   - 立即数的低5位与高7位组合形成完整的12位偏移量。

**存储字节、半字和字**

1. **`sb`**：存储字节（Store Byte）。
2. **`sh`**：存储半字（Store Halfword），存储16位（2字节）。
3. **`sw`**：存储字（Store Word），存储32位数据。

| imm[11:5] | rs2  | rs1  | funct3 | imm[4:0] | opcode  | Instruction |
| --------- | ---- | ---- | ------ | -------- | ------- | ----------- |
| imm[11:5] | rs2  | rs1  | 000    | imm[4:0] | 0100011 | sb          |
| imm[11:5] | rs2  | rs1  | 001    | imm[4:0] | 0100011 | sh          |
| imm[11:5] | rs2  | rs1  | 010    | imm[4:0] | 0100011 | sw          |

**说明：**

1. **字段解析**：
   - `imm[11:5]` 和 `imm[4:0]`：立即数分为高7位和低5位，用于偏移量。
   - `rs2`：源寄存器2，用于存储的数据。
   - `rs1`：源寄存器1，基址寄存器。
   - `funct3`：功能码，占3位，定义存储操作的类型（字节、半字或字）。
   - `opcode`：操作码，占7位，固定为 `0100011`。
   - `Instruction`：指令名称。
2. **功能描述**：
   - 不同的 `funct3` 值用于区分存储字节（`sb`）、半字（`sh`）和字（`sw`）。
   - 立即数的高低位组合形成完整的12位偏移量，用于存储目标地址计算。

### 6.B格式

**分支通常用于循环（如 `if-else`, `while`, `for`）**

- 循环通常很小（< 50 条指令）。
- 函数调用和无条件跳转由跳转指令（J-格式）处理。

------

**回顾（Recall）：**

- 指令存储在内存的局部区域（代码/文本区域）。
- 最大分支距离受代码大小限制。
- 当前指令的地址存储在程序计数器（PC）中。

**PC-相对寻址 (PC-Relative Addressing)**：

- 使用立即数 (immediate) 字段作为 PC 的补码偏移量。
- 分支通常只会使 PC 改变少量值。
- 可以指定从 PC 开始的 ±2¹¹ 个“单位”地址范围。
- （稍后我们会看到，可以将 12 位偏移量编码为立即数。）

------

**为什么不使用字节作为从 PC 偏移的单位？**

- 因为指令是 32 位（4 字节）对齐的。
- 我们不会跳转到指令的中间部分。

**一个想法：**

为了扩展单条分支指令的作用范围，可以在将偏移量加到 PC 之前，将偏移量乘以 4 个字节。

- 这样可以使单条分支指令达到 ±2¹¹ × 32 位指令的范围（相对于 PC）。

**结果**：

- 相比使用字节偏移，这种方法的作用范围扩大了 4 倍。

#### 假设

**分支行为：**

如果**不**执行分支（`don't take the branch`）：

```makefile
PC = PC + 4   （即，跳到下一条指令）
```

如果执行分支（`do take the branch`）：

```makefile
PC = PC + immediate * 4
```

------

**观察 (Observations):**

- **`immediate`** 是跳转的指令数量（以单词为单位，而不是字节）。
- 偏移量可以是：
  - 正数（向前跳转）。
  - 负数（向后跳转）。

**RISC-V 的扩展支持**

RISC-V 的基础 ISA 支持：

- 16 位压缩指令（compressed instructions）。
- 可变长度的指令（其长度为 16 位的倍数）。

为了实现这一点：

- **RISC-V 将分支偏移量按 2 字节缩放，即使没有 16 位指令**。

------

**后果**

1. **分支范围减半**：

   - 这意味着可能的一半目标地址在仅支持 32 位指令的 RISC-V 处理器上将会出错（如本课程中使用的那种）。

2. **条件分支的限制**：

   - RISC-V 的条件分支只能达到：

     ```
     ±2¹⁰ × 32 位指令的范围，相对于 PC。
     ```

#### 实际

**分支行为：**

如果**不**执行分支（`don't take the branch`）：

```makefile
PC = PC + 4   （即跳到下一条指令）
```

如果执行分支（`do take the branch`）：

```makefile
PC = PC + immediate * 2
```

```plaintext
  31      30         25 24        20 19       15 14     12 11       7 6       0
 ┌────────┬───────────┬───────────┬───────────┬─────────┬───────────┬─────────┐
 │ imm[12]│ imm[10:5] │    rs2    │    rs1    │ funct3  │ imm[4:1|11]│ opcode  │
 └────────┴───────────┴───────────┴───────────┴─────────┴───────────┴─────────┘
      1          6           5           5         3          4          7
```

**B-格式（B-Format）指令格式**

- B-格式基本与 S-格式相同，包含两个寄存器源（`rs1/rs2`）和一个 12 位的立即数（`imm[12:1]`）。

------

**立即数（Immediate）的作用**

- 现在，立即数表示从 `-4096` 到 `+4094` 的值，以 2 字节为增量。
- 这 12 位立即数对齐为偶数的 13 位有符号字节偏移量（最低位总是 0，因此无需存储该位）。

```plaintext
┌──────────────┬──────┬──────┬─────┬──────────┬──────────┬───────┐
│  imm[12|10:5] │  rs2 │  rs1 │ funct3 │ imm[4:1|11] │ opcode   │ name  │
├──────────────┼──────┼──────┼─────┼──────────┼──────────┼───────┤
│  imm[12|10:5] │  rs2 │  rs1 │ 000 │ imm[4:1|11] │ 1100011  │ beq   │
│  imm[12|10:5] │  rs2 │  rs1 │ 100 │ imm[4:1|11] │ 1100011  │ bne   │
│  imm[12|10:5] │  rs2 │  rs1 │ 101 │ imm[4:1|11] │ 1100011  │ blt   │
│  imm[12|10:5] │  rs2 │  rs1 │ 110 │ imm[4:1|11] │ 1100011  │ bge   │
│  imm[12|10:5] │  rs2 │  rs1 │ 111 │ imm[4:1|11] │ 1100011  │ bltu  │
│  imm[12|10:5] │  rs2 │  rs1 │ 111 │ imm[4:1|11] │ 1100011  │ bgeu  │
└──────────────┴──────┴──────┴─────┴──────────┴──────────┴───────┘

```

### 字段解释：

1. **imm[12|10:5]**：
   - 偏移量的高位部分。
2. **rs2 和 rs1**：
   - 寄存器源。
3. **funct3**：
   - 功能码，用于区分操作类型。
4. **imm[4:1|11]**：
   - 偏移量的低位部分。
5. **opcode**：
   - 操作码，标识指令类型。
6. **name**：
   - 指令名称（如 `beq`、`bne` 等）。

### 7.长立即数

**如果我们移动代码，分支立即数字段的值会改变吗？**

- 如果只移动代码中的某几行，那么会改变。
- 如果移动整个代码块，那么不会改变（称为“位置无关代码”）。

------

**如果目标位置距离分支超过 2102^{10}210 条指令，我们该怎么办？**

- 其他指令可以帮助我们解决这个问题。

```plaintext
  31                12 11     7 6     0
 ┌────────────────────┬───────┬───────┐
 │     imm[31:12]     │   rd  │ opcode│
 └────────────────────┴───────┴───────┘
         20 bits        5 bits  7 bits
```

在 32 位指令字的高 20 位中包含一个 20 位的立即数。
包含一个目标寄存器，`rd`。
用于两条指令：

- `lui` — 加载高位立即数）。
- `auipc` — 将高位立即数加到程序计数器 `PC` 中。

- **`LUI`** 指令将目标寄存器的高 20 位写入立即数值，并清零低 12 位。
- 配合 `ADDI` 指令设置低 12 位，可以通过两条指令（`LUI` 和 `ADDI`）在寄存器中创建任意 32 位值。

------

**示例：**

```assembly
lui x10, 0x87654     # x10 = 0x87654000
addi x10, x10, 0x321 # x10 = 0x87654321
```

**AUIPC（Add Upper Immediate to PC）**

- 将高位立即数值加到程序计数器（PC）中，并将结果存储到目标寄存器中。
- 用于 PC 相对寻址。

### 8.J格式

```plaintext
     31   30           21   20   19     12 11    7 6     0
 ┌────────┬─────────────┬───────┬─────────┬───────┬───────┐
 │ imm[20]│ imm[10:1]   │ imm[11]│ imm[19:12] │  rd   │ opcode│
 └────────┴─────────────┴───────┴─────────┴───────┴───────┘
     1         10           1        8         5       7

```

**`jal` 指令**：

- 将 `PC+4` 保存到寄存器 `rd` 中（作为返回地址）。
- 汇编器的 `j` 指令是伪指令，使用 `JAL`，但将 `rd` 设置为 `x0` 来丢弃返回地址。

**设置程序计数器（PC）**：

- 设置为 `PC = PC + offset`（PC 相对跳转）。

**目标位置**：

- 目标在距离当前 PC ±2¹⁹ 的范围内，以 2 字节为增量。
- 相当于 ±2¹⁸ 条 32 位指令的范围。

**立即数编码**：

- 类似于分支指令进行优化，以降低硬件成本。

#### jalr

```plaintext
 31     20 19  15 14   12 11    7 6      0
 ┌────────┬──────┬───────┬───────┬───────┬───────┐
 │ imm[11:0] │ rs1  │ func3 │  rd   │ opcode │
 └────────┴──────┴───────┴───────┴───────┴───────┘
      12       5       3      5       7
```

1. **`jalr` 指令：**
   - **语法：** `jalr rd, rs, immediate`
   - 将 `PC+4` 写入寄存器 `rd`（作为返回地址）。
   - 设置 `PC = rs + immediate`。
   - 使用与算术运算和加载指令相同的立即数。
2. **特点：**
   - **无**乘以 2 字节的操作。
   - 与分支指令和 `jal` 指令形成对比。

## 12.编译，汇编，链接和加载

### 1.解释和翻译

在某些情况下，运行程序的一种方法是解释，解释器是一个运行其他程序的程序。

翻译的思想是，将一种语言翻译成更低级的形式，在曲线或光谱上更靠右，然后直接运行它。

**我们如何运行用源语言编写的程序？**

- **解释器 (Interpreter)**: 直接在源语言中执行程序。
- **翻译器 (Translator)**: 将源语言中的程序转换为另一种语言中的等效程序。

**为什么在软件中解释机器语言？**

- **例如：**
  **VENUS RISC-V 模拟器** 对学习/调试非常有用
  **Apple Macintosh 转换**
- **切换**：从 Motorola 680x0 ISA 转换到 PowerPC（在 x86 之前）。
- **可能需要**：所有程序从高级语言重新翻译。
- **相反**：让可执行文件包含旧的和/或新的机器代码，必要时通过软件解释旧代码（仿真）。

**通常解释器更容易编写**

- **例如**：你在 CS61A 中已经做过了！

**解释器更接近高级语言，因此可以提供更好的错误信息**（例如：VENUS）。

- 翻译器的反应：添加额外的信息以帮助调试（例如：行号、名称）。

**解释器更慢**（大约慢10倍？），**代码更小**（大约小2倍？）。

**解释器提供指令集独立性**：可以在任何机器上运行。

**翻译/编译的代码几乎总是更高效，因此性能更高：**

- 对许多应用程序来说很重要，尤其是操作系统。

**翻译/编译可以帮助将程序的“源代码”隐藏起来：**

- 一种在市场中创造价值的模式（例如：微软将所有的源代码保密）。
- 替代模式：“开源”，通过发布源代码并培养开发者社区来创造价值。

### 2.编译器

加载器是操作系统的一部分，加载器负责将磁盘上的程序a.out加载到内存中，并设置它需要设置的所有东西，很多复杂的事情需要设置，然后运行程序

**输入：** 高级语言代码（例如：`foo.c`）
**输出：** 汇编语言代码（例如：`foo.s`，用于 RISC-V）

**注意：** 输出**可能**包含伪指令（pseudo-instructions）。

**伪指令：** 汇编器可以理解但不属于机器指令的指令。
**例如：** 将值从 `t2` 复制到 `t1`：

```asm
mv t1, t2  ==>  addi t1, t2, 0
```

### 3.汇编器

**输入：** 汇编语言代码（包含伪操作）
（例如：`foo.s`，适用于 RISC-V）

**输出：** 目标代码、信息表（仅限真正的汇编）
（例如：`foo.o`，适用于 RISC-V）

- **读取并使用指令（Directives）**
- **替换伪指令**
- **生成机器语言**
- **创建目标文件（Object File）**

**为汇编器提供指令，但不生成机器指令**

- **`.text`：**
  将后续内容放入用户文本段（机器代码）。
- **`.data`：**
  将后续内容放入用户数据段（源文件数据以二进制形式存储）。
- **`.globl sym`：**
  声明符号 `sym` 为全局，可被其他文件引用。
- **`.string str`：**
  在内存中存储字符串 `str` 并以空字符（null）结尾。
- **`.word w1...wn`：**
  将 `n` 个 32 位数量存储在连续的内存字中。

------

**汇编器将机器语言指令的便捷变体视为真实指令**

**伪指令（Pseudo）：**

- `mv t0, t1`
- `neg t0, t1`
- `li t0, imm`
- `not t0, t1`
- `beqz t0, loop`
- `la t0, str`

**真实指令（Real）：**

- `addi t0, t1, 0`
- `sub t0, zero, t1`
- `addi t0, zero, imm`
- `xori t0, t1, -1`
- `beq t0, zero, loop`
- `lui t0, str[31:12]`
  `addi t0, t0, str[11:0]` 或
  `auipc t0, str[31:12]`
  `addi t0, t0, str[11:0]`

**简单情况（Simple Case）：**

- 算术、逻辑、移位等
- 所有必要的信息已经包含在指令中。

**那么分支和跳转（Branches and Jumps）呢？**

- 基于程序计数器（PC-Relative），例如：`beq/bne` 和 `jal`。
- 一旦伪指令被替换为真实指令，我们就知道分支/跳转需要跳过多少指令。

**因此，这些可以被处理。**

**关于基于 PC 的相对跳转（`jal`）和分支（`beq`, `bne`）呢？**

- `j offset` 伪指令会扩展为 `jal zero, offset`。
- 只需计算目标和跳转之间的指令“半字”的数量，以确定偏移量：
  **位置无关代码**（Position-Independent Code，PIC）。

**那么关于对静态数据的引用呢？**

- `la` 会被拆分为 `lui` 和 `addi`（对于 PIC 使用 `auipc/addi`）。
- 这些需要数据的完整 32 位地址。

**这些目前无法确定，因此我们创建两个表……**

**在此文件中可能被其他文件使用的“项目”列表**

**它们是什么？**

- **Labels（标签）：** 函数调用
- **Data（数据）：** `.data` 段中的任何内容；可被跨文件访问的变量

**此文件需要其地址的“项目”列表**

**它们是什么？**

- **任何被跳转到的绝对标签：`jal`，`jalr`**
  - **内部**
  - **外部**（包括库文件）
  - 例如 la指令
    - **例如：** 用于 `jalr` 的基寄存器
- **静态段中的任何数据**
  - 例如 la指令
    - **例如：** 用于 `lw/sw` 的基寄存器

- **目标文件头（object file header）：**
  目标文件中其他部分的大小和位置。
- **文本段（text segment）：**
  机器代码。
- **数据段（data segment）：**
  源文件中静态数据的二进制表示。
- **重定位信息（relocation information）：**
  标识需要稍后修正的代码行。
- **符号表（symbol table）：**
  此文件中标签和静态数据的列表，可供引用。
- **调试信息（debugging information）：**

**标准格式为 ELF（除 MS 以外）。**

### 4.链接器

**输入：** 目标代码文件，信息表（例如：`foo.o`, `libc.o`，用于 RISC-V）。

**输出：** 可执行代码（例如：`a.out`，用于 RISC-V）。

**将多个目标文件（`.o` 文件）组合成一个可执行文件（称为“链接”）。**

**启用文件的单独编译：**

- 对单个文件的更改无需重新编译整个程序。
  - **例如：** Linux 源代码 > 2000 万行！
- **旧名称“链接编辑器”（Link Editor）：** 源于编辑跳转和链接指令中的“链接”。

**第 1 步：** 从每个 `.o` 文件中提取 **文本段（text segment）** 并将它们组合在一起。

**第 2 步：** 从每个 `.o` 文件中提取 **数据段（data segment）**，将它们组合在一起，并将其连接到文本段的末尾。

**第 3 步：** 解析引用：

- 遍历重定位表（Relocation Table）；处理每个条目。
- 即：填充所有**绝对地址（absolute addresses）**。

**基于 PC 的相对寻址（PC-Relative Addressing）：**
（例如：`beq`, `bne`, `jal`, `auipc/addi`）

- **从不需要重定位**（PIC：位置无关代码）。

**绝对函数地址（Absolute Function Address）：**
（例如：`auipc/jalr`）

- **始终需要重定位**。

**外部函数引用（External Function Reference）：**
（例如：`auipc/jalr`）

- **始终需要重定位**。

**静态数据引用（Static Data Reference）：**
（通常使用 `lui/addi`）

- **始终需要重定位**。

**哪些指令需要重定位编辑？**

- **J-格式：跳转/跳转并链接（jump/jump and link）**
  - 示例：`jal`，涉及目标地址 `xxxxx` 和寄存器 `rd`。
- **I-, S-格式：**
  - **相对于全局指针（global pointer, `gp`）加载和存储静态区域中的变量。**
  - 示例：`lw` 和 `sw`，涉及寄存器 `rd`（或 `rs1`）和 `gp`。
- **条件分支呢？**
  - 示例：`beq`, `bne`，涉及寄存器 `rs1` 和 `rs2`。

**基于 PC 的相对寻址在代码移动时依然有效（preserved）。**

**链接器（Linker）假设**第一个文本段的第一个字位于地址 `0x10000`（适用于 RV32）。

- （稍后在学习“虚拟内存”时会详细讨论）

**链接器已知的信息：**

- 每个文本段和数据段的长度。
- 文本段和数据段的排列顺序。

**链接器计算的信息：**

- 每个需要跳转的标签（内部或外部）的**绝对地址**，以及每个被引用数据的绝对地址。

**解决引用：**

- 在所有“用户”符号表中搜索引用（数据或标签）。
- 如果未找到，则在库文件中搜索（例如：`printf`）。
- 一旦确定了绝对地址，就在机器代码中适当地填充地址。

**链接器的输出：**
包含文本和数据（以及头部信息）的可执行文件。

**我们描述的是传统方法：静态链接（statically-linked）方式**

- **库（Library）现在是可执行文件的一部分，**
  因此，如果库更新，我们不会获得修复（除非我们有源代码并重新编译）。
- **即使没有使用整个库，也会包含整个库。**
- **可执行文件是自包含的（self-contained）。**

**替代方法是动态链接库（dynamically-linked libraries，DLL），**
常见于 Windows 和 UNIX 平台。S

**空间/时间问题（Space/time issues）：**

- **优点：**
  - 存储程序需要更少的磁盘空间。
  - 发送程序需要更少的时间。
  - 如果两个程序共享一个库，执行这两个程序需要更少的内存。
- **缺点：**
  - 在运行时需要额外的时间开销来完成链接。

------

**升级（Upgrades）：**

- **优点：**
  - 替换一个文件（例如：`libXYZ.so`）就可以升级所有使用库 `XYZ` 的程序。
- **缺点：**
  - 拥有可执行文件已经不再足够。

**动态链接的主流方法使用机器代码作为“最低公分母”：**

- 链接器（Linker）不会使用程序或库是如何编译的信息（即：使用什么编译器或语言）。
- 可以描述为“在机器代码级别进行链接”。
- 这并不是唯一的实现方式……

### 5.加载器

**输入：** 可执行代码（例如：`a.out`，用于 RISC-V）

**输出：** （程序运行）

- 可执行文件存储在磁盘上。
- 当程序运行时，加载器（Loader）的任务是将其加载到内存中并启动运行。

**实际上，加载器就是操作系统（OS）。**

- 加载是操作系统任务之一。

- **读取可执行文件的头部信息**以确定文本段和数据段的大小。
- **为程序创建新的地址空间**，足够容纳文本段和数据段，同时包括一个栈段（stack segment）。
- **将指令和数据从可执行文件复制到新的地址空间中。**
- **将传递给程序的参数复制到栈中。**
- **初始化机器寄存器：**
  - 大多数寄存器被清零，但栈指针被分配到第一个空闲栈位置的地址。
- **跳转到启动例程**：该例程将程序的参数从栈复制到寄存器并设置程序计数器（PC）。
  - 如果主例程返回，启动例程通过退出系统调用终止程序。

## 13.同步数字系统 (SDS) 介绍：开关、晶体管、信号与波形

### 1.开关

处理器的硬件，例如 RISC-V，是一个同步数字系统。

同步：

- 所有操作由中央时钟协调
- 系统的“心跳”！

数字：

- 所有值由离散值表示
- 电信号被视为1和0；组合在一起形成字（word，这里可能指的是计算机中的“字”或“字长”）。

- 当 A 为 1 时，闭合开关；当 A 为 0 时，打开开关。

**一个简单电路:**

```scss
        +----[A]----+
        |           |
       ( )          |
      [S]           |
        |           |
       ( )          |
      [Z]           |
        |           |
       ( )          |
        +-----------+
```

- 如果 A 是“1”或被断言，则闭合开关并点亮灯泡 (Z)。

- 如果 A 是“0”或未被断言，则打开开关并关闭灯泡 (Z)。

电路的逻辑表达式为：Z = A

**如何将开关组合成更复杂的布尔函数:**

- AND（与）：当 A 和 B 都为“1”或被断言时，开关闭合，输出 Z 为真。

```lua
        A ------+
                |
                |
               ( )---+
               |     |
        B------| AND |---- Z
               |     |
               +-----+
```

- OR（或）：当 A 或 B 至少有一个为“1”或被断言时，开关闭合，输出 Z 为真。

```lua
        A ------+
                |
                |
               ( )---+
               |     |
        B------| OR  |---- Z
               |     |
               +-----+
```

逻辑表达式为：

- Z = A AND B
- Z = A OR B

### 2.晶体管

**现代数字系统在 CMOS（互补金属氧化物半导体）技术下的设计：**

- MOS：金属氧化物半导体
- C 代表互补（complementary），指的是通常打开（normally-open）和通常关闭（normally-closed）的开关
- MOS 晶体管作为电压控制的开关

CMOS 技术是一种广泛用于集成电路的制造工艺，它利用了两种类型的 MOS 晶体管——NMOS（通常关闭）和 PMOS（通常打开）——来构建逻辑门和其他数字电路。这种技术因其低功耗特性而受到青睐，因为在没有输入信号变化时，CMOS 电路几乎不消耗功率。

MOS晶体管的三个端子：漏极（Drain）、栅极（Gate）和源极（Source），以及它们如何作为开关工作。

1. **三个端子：漏极、栅极、源极**
   - 漏极（D）：电流流出的端子。
   - 栅极（G）：控制端子，通过施加电压来控制晶体管的开关状态。
   - 源极（S）：电流流入的端子。
2. **开关动作**
   - 如果栅极端子上的电压比源极端子上的电压高/低一定量，那么在漏极和源极之间就会建立导电路径。
3. **记忆提示**
   - n沟道（n-channel）：当栅极电压较低时，晶体管打开；当栅极电压高于源极电压加上一个阈值电压（ε）时，晶体管关闭。
   - p沟道（p-channel）：当栅极电压较低时，晶体管关闭；当栅极电压高于源极电压加上一个阈值电压（ε）时，晶体管打开。

**n沟道晶体管（NMOS）：**

- 栅极（G）没有圆圈。
- 源极（S）和漏极（D）之间的路径在栅极电压较低时打开。

```lua
	   D
       |
       |
      -----
      |   |
 G --|   |
      |   |
 S ------
```

**p沟道晶体管（PMOS）：**

- 栅极（G）有一个圆圈（表示反向电压）。
- 源极（S）和漏极（D）之间的路径在栅极电压较高时打开。

```lua
	   D
       |
       |
      -----
      |   |
 G --o   |
      |   |
 S ------
```

### 3.非门

```scss
         +3V (电源)
            |
           ( )
           | | PMOS
           | |
           | |---- Y (输出)
           | |
           | |
           | |      
        ----|----  
            |
            | NMOS
            | |
           ( ) 
            |
            |---- GND (地，0V)
                   |
                   |
                 X (输入)

```

**X 和 Y 之间的关系是什么？**

X 点的电压比 Y 点高 3V。如果这是一个逻辑问题，那么 X 和 Y 之间的关系可以被描述为 X = 1, Y = 0，其中 1 代表高电位（3V），0 代表低电位（0V）。

### 4.集成电路芯片的基本构成和逻辑门的构建方式：

1. **芯片的基本构成**：
   - 芯片由晶体管和导线组成。
   - 晶体管的小组合可以形成有用的构建模块。
2. **NAND门的构建**：
   - 一个NAND门由两个晶体管组成。
   - 输入端标记为a和b，输出端标记为c。
   - 当a和b都为高电平（"1"，连接到电压源）时，输出c为低电平（"0"，连接到地）。
   - 当a或b中至少有一个为低电平（"0"，连接到地）时，输出c为高电平（"1"）。
3. **NAND门的逻辑功能**：
   - 真值表显示，只有当a和b都为0时，输出c才为1；在所有其他情况下，输出c为0。

**NAND 门电路图**(**与非门**)

```lua
           +3V (电压源)
               |
               |
               +---+   +---+
               |   |   |   |
           a --|>  |   |   |-- c (输出)
               |   |   |   |
           b --|>  |---|   |
               |   |   |   |
               +---+   +---+
                   |     |
                ----     ----
                   |       |
                 GND     GND
```

**解释：**

1. 输入 a 和 b：
   - 输入 **a** 和 **b** 分别连接到两个 **n沟道晶体管（NMOS）** 的栅极。
   - 输入 **a** 和 **b** 可以为高电平（"1"）或低电平（"0"）。
2. 两个 NMOS 晶体管的连接：
   - 两个 NMOS 晶体管的源极（S）都连接到地（GND）。
   - 两个 NMOS 晶体管的漏极（D）连接到输出 **c**。
   - 输出 **c** 通过两个 NMOS 晶体管控制。
3. 工作原理：
   - **当 a 和 b 都为高电平（1）** 时，两个 NMOS 晶体管都导通，输出 **c** 被拉到地（低电平 "0"）。
   - **当 a 或 b 中至少有一个为低电平（0）** 时，至少有一个 NMOS 晶体管不导通，输出 **c** 被拉到高电平（"1"）。

**逻辑真值表：**

| 输入 a | 输入 b | 输出 c |
| ------ | ------ | ------ |
| 0      | 0      | 1      |
| 0      | 1      | 1      |
| 1      | 0      | 1      |
| 1      | 1      | 0      |

### 5.型号和波形

1. **周期性信号**：
   - 图中展示了一个周期性方波信号，其中T表示周期（Time period）。
   - 周期T与频率（freq）的关系为：T = 1/freq，大约为1/5秒。
2. **信号的传输特性**：
   - 当数字信号仅被视为1或0时，它们通过导线连续传输。
   - 传输被认为是有效的即时性，即信号的传输几乎是瞬间完成的。
   - 这意味着在任何给定时间，导线上只包含一个值（1或0）。

```markdown
电压 (V)
  3V  |    _____          _____          _____
      |    |    |         |    |         |    |
      |    |    |         |    |         |    |
  0V  |____|    |_________|    |_________|    |_______ 时间 (t)
             T           T           T

```

### 6.加法器传播延迟

**加法器传播延迟**（Adder Propagation Delay）是指在数字电路中，当输入信号发生变化时，加法器的输出信号响应所需的时间。这是加法器的一个重要性能指标，尤其在高速电路设计中，它对系统的整体速度至关重要。

**加法器的基本工作原理：**

- 一个简单的 **半加器（Half Adder）** 有两个输入（A 和 B），并计算一个和（Sum）和一个进位（Carry）。
- 一个 **全加器（Full Adder）** 具有三个输入（A、B 和进位输入 Cin），输出一个和（Sum）和一个进位输出（Carry Out）。

**加法器传播延迟的影响因素：**

1. **基本门的延迟**：加法器是由基本的逻辑门（如与门、或门、异或门）组成的，而这些门本身都有一定的延迟。传播延迟的大小依赖于这些门的延迟时间。
2. **级联加法器（如多位加法器）**：在多位加法器中，每个加法器单元的进位输出（Carry Out）会传递到下一个加法器的进位输入（Carry In）。这种级联会造成信号传播的累积延迟。
3. **进位链的延迟**：加法器中最关键的延迟通常与进位链（Carry Chain）相关。当一个加法器的进位输出成为下一个加法器的进位输入时，信号需要逐步传播，这会导致较长的传播延迟。

**传播延迟的计算：**

传播延迟通常是通过以下两种方式来描述的：

1. **最大传播延迟（Maximum Propagation Delay）**：表示在最坏情况下，从输入信号改变到输出信号稳定所需要的时间。对于一个加法器，最大传播延迟是从输入信号到输出结果（和或进位）最慢的路径所需的时间。
2. **平均传播延迟**：这是加法器中的所有路径的传播延迟的平均值。一般来说，平均传播延迟较小，因为它不会考虑最坏情况的进位链延迟。

**组合逻辑（Combinational Logic, CL）电路和状态元素（State Elements）电路。**

1. **组合逻辑（CL）电路**：
   - 组合逻辑电路的输出仅依赖于当前的输入值。
   - 图片中提到，之前讨论的加法器电路就是一个组合逻辑电路的例子。
   - 组合逻辑电路的输出是输入的函数，类似于数学中的纯函数，表示为 y = f(x)。这意味着在任何给定时刻，输出完全由输入决定，而且电路在不同时间的运行之间没有记忆功能，即无法存储信息以影响下一次的输出，没有副作用。
2. **状态元素**：
   - 状态元素是用于存储信息的电路。
   - 这些电路能够记住之前的输入状态，并可能根据这些状态来影响当前或未来的输出。

**电路中的脉冲由什么控制**

1. **时钟控制电路的脉冲**：
   - 时钟信号是数字电路中的同步信号，它控制着电路中操作的时机。时钟信号通常是一个周期性的方波，用于同步电路中的所有操作。
2. **电压是模拟的，量化为0/1**：
   - 在数字电路中，电压虽然在物理上是模拟的，但它们被量化为两个状态：高电平（通常表示为1）和低电平（通常表示为0）。
3. **电路延迟是生活的事实**：
   - 在实际的电路中，信号从一个地方传播到另一个地方需要时间，这种延迟是不可避免的，并且对电路设计有重要影响。
4. **两种类型的电路**：
   - 无状态组合逻辑（Stateless Combinational Logic）：这类电路的输出仅依赖于当前的输入，不依赖于之前的状态。常见的组合逻辑包括与门（AND, &）、或门（OR, |）和非门（NOT, ~）。
   - 状态电路（State Circuits）：这类电路包含存储元件，如寄存器（registers），它们能够存储信息并根据存储的状态来影响输出。
